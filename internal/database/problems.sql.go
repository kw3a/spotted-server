// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: problems.sql

package database

import (
	"context"
)

const createProblem = `-- name: CreateProblem :exec

INSERT INTO problem (id, description, title, memory_limit, time_limit, quiz_id)
VALUES (?,?,?,?,?,?)
`

type CreateProblemParams struct {
	ID          string
	Description string
	Title       string
	MemoryLimit int32
	TimeLimit   float64
	QuizID      string
}

func (q *Queries) CreateProblem(ctx context.Context, arg CreateProblemParams) error {
	_, err := q.db.ExecContext(ctx, createProblem,
		arg.ID,
		arg.Description,
		arg.Title,
		arg.MemoryLimit,
		arg.TimeLimit,
		arg.QuizID,
	)
	return err
}

const getProblem = `-- name: GetProblem :many
SELECT problem.id, problem.description, problem.title, problem.memory_limit, problem.time_limit, problem.quiz_id, language.id as language_id, language.name as language_name, language.version as language_version, "" AS input, "" AS output
FROM problem
JOIN language_problem ON problem.id = language_problem.problem_id
JOIN language ON language_problem.language_id = language.id
WHERE problem.quiz_id = ? and problem.id = ?
UNION
SELECT problem.id, problem.description, problem.title, problem.memory_limit, problem.time_limit, problem.quiz_id, 0 AS language_id, "" AS language_name, 0 AS language_version, example.input, example.output
FROM problem
JOIN example ON problem.id = example.problem_id
WHERE problem.quiz_id = ? and problem.id = ?
`

type GetProblemParams struct {
	QuizID   string
	ID       string
	QuizID_2 string
	ID_2     string
}

type GetProblemRow struct {
	ID              string
	Description     string
	Title           string
	MemoryLimit     int32
	TimeLimit       float64
	QuizID          string
	LanguageID      int32
	LanguageName    string
	LanguageVersion int32
	Input           string
	Output          string
}

func (q *Queries) GetProblem(ctx context.Context, arg GetProblemParams) ([]GetProblemRow, error) {
	rows, err := q.db.QueryContext(ctx, getProblem,
		arg.QuizID,
		arg.ID,
		arg.QuizID_2,
		arg.ID_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProblemRow
	for rows.Next() {
		var i GetProblemRow
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Title,
			&i.MemoryLimit,
			&i.TimeLimit,
			&i.QuizID,
			&i.LanguageID,
			&i.LanguageName,
			&i.LanguageVersion,
			&i.Input,
			&i.Output,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProblems = `-- name: GetProblems :many
SELECT problem.id, problem.description, problem.title, problem.memory_limit, problem.time_limit, problem.quiz_id, language.id as language_id, language.name as language_name, language.version as language_version, "" AS input, "" AS output
FROM problem
JOIN language_problem ON problem.id = language_problem.problem_id
JOIN language ON language_problem.language_id = language.id
WHERE problem.quiz_id = ?
UNION
SELECT problem.id, problem.description, problem.title, problem.memory_limit, problem.time_limit, problem.quiz_id, 0 AS language_id, "" AS language_name, 0 AS language_version, example.input, example.output
FROM problem
JOIN example ON problem.id = example.problem_id
WHERE problem.quiz_id = ?
`

type GetProblemsParams struct {
	QuizID   string
	QuizID_2 string
}

type GetProblemsRow struct {
	ID              string
	Description     string
	Title           string
	MemoryLimit     int32
	TimeLimit       float64
	QuizID          string
	LanguageID      int32
	LanguageName    string
	LanguageVersion int32
	Input           string
	Output          string
}

func (q *Queries) GetProblems(ctx context.Context, arg GetProblemsParams) ([]GetProblemsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProblems, arg.QuizID, arg.QuizID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProblemsRow
	for rows.Next() {
		var i GetProblemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Title,
			&i.MemoryLimit,
			&i.TimeLimit,
			&i.QuizID,
			&i.LanguageID,
			&i.LanguageName,
			&i.LanguageVersion,
			&i.Input,
			&i.Output,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
