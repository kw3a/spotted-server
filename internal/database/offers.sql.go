// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: offers.sql

package database

import (
	"context"
	"time"
)

const archiveOffer = `-- name: ArchiveOffer :exec
UPDATE offer
JOIN company ON offer.company_id = company.id
SET offer.status = -1
WHERE offer.id = ? AND company.user_id = ?
`

type ArchiveOfferParams struct {
	ID     string
	UserID string
}

func (q *Queries) ArchiveOffer(ctx context.Context, arg ArchiveOfferParams) error {
	_, err := q.db.ExecContext(ctx, archiveOffer, arg.ID, arg.UserID)
	return err
}

const getOffer = `-- name: GetOffer :one
SELECT offer.id, offer.created_at, offer.updated_at, offer.title, offer.about, offer.requirements, offer.benefits, offer.status, offer.min_wage, offer.max_wage, offer.company_id, company.name as company_name
FROM offer
JOIN company ON offer.company_id = company.id
WHERE offer.id = ?
LIMIT 1
`

type GetOfferRow struct {
	ID           string
	CreatedAt    time.Time
	UpdatedAt    time.Time
	Title        string
	About        string
	Requirements string
	Benefits     string
	Status       int32
	MinWage      int32
	MaxWage      int32
	CompanyID    string
	CompanyName  string
}

func (q *Queries) GetOffer(ctx context.Context, id string) (GetOfferRow, error) {
	row := q.db.QueryRowContext(ctx, getOffer, id)
	var i GetOfferRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.About,
		&i.Requirements,
		&i.Benefits,
		&i.Status,
		&i.MinWage,
		&i.MaxWage,
		&i.CompanyID,
		&i.CompanyName,
	)
	return i, err
}

const getOfferByQuiz = `-- name: GetOfferByQuiz :one
SELECT offer.id, offer.created_at, offer.updated_at, offer.title, offer.about, offer.requirements, offer.benefits, offer.status, offer.min_wage, offer.max_wage, offer.company_id
FROM offer
JOIN quiz ON offer.id = quiz.offer_id
WHERE quiz.id = ?
LIMIT 1
`

func (q *Queries) GetOfferByQuiz(ctx context.Context, id string) (Offer, error) {
	row := q.db.QueryRowContext(ctx, getOfferByQuiz, id)
	var i Offer
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.About,
		&i.Requirements,
		&i.Benefits,
		&i.Status,
		&i.MinWage,
		&i.MaxWage,
		&i.CompanyID,
	)
	return i, err
}

const getOfferByUser = `-- name: GetOfferByUser :one
SELECT offer.id, offer.created_at, offer.updated_at, offer.title, offer.about, offer.requirements, offer.benefits, offer.status, offer.min_wage, offer.max_wage, offer.company_id, company.name as company_name
FROM offer
JOIN company ON offer.company_id = company.id
JOIN user ON company.user_id = user.id
WHERE offer.id = ? AND user.id = ?
LIMIT 1
`

type GetOfferByUserParams struct {
	ID   string
	ID_2 string
}

type GetOfferByUserRow struct {
	ID           string
	CreatedAt    time.Time
	UpdatedAt    time.Time
	Title        string
	About        string
	Requirements string
	Benefits     string
	Status       int32
	MinWage      int32
	MaxWage      int32
	CompanyID    string
	CompanyName  string
}

func (q *Queries) GetOfferByUser(ctx context.Context, arg GetOfferByUserParams) (GetOfferByUserRow, error) {
	row := q.db.QueryRowContext(ctx, getOfferByUser, arg.ID, arg.ID_2)
	var i GetOfferByUserRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.About,
		&i.Requirements,
		&i.Benefits,
		&i.Status,
		&i.MinWage,
		&i.MaxWage,
		&i.CompanyID,
		&i.CompanyName,
	)
	return i, err
}

const getOffers = `-- name: GetOffers :many
SELECT offer.id, offer.created_at, offer.updated_at, offer.title, offer.about, offer.requirements, offer.benefits, offer.status, offer.min_wage, offer.max_wage, offer.company_id, company.name as company_name, company.image_url as company_image_url
FROM offer
JOIN company ON offer.company_id= company.id
WHERE offer.status = 1
ORDER BY offer.created_at DESC
LIMIT ? OFFSET ?
`

type GetOffersParams struct {
	Limit  int32
	Offset int32
}

type GetOffersRow struct {
	ID              string
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Title           string
	About           string
	Requirements    string
	Benefits        string
	Status          int32
	MinWage         int32
	MaxWage         int32
	CompanyID       string
	CompanyName     string
	CompanyImageUrl string
}

func (q *Queries) GetOffers(ctx context.Context, arg GetOffersParams) ([]GetOffersRow, error) {
	rows, err := q.db.QueryContext(ctx, getOffers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOffersRow
	for rows.Next() {
		var i GetOffersRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.About,
			&i.Requirements,
			&i.Benefits,
			&i.Status,
			&i.MinWage,
			&i.MaxWage,
			&i.CompanyID,
			&i.CompanyName,
			&i.CompanyImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOffersByCompany = `-- name: GetOffersByCompany :many
SELECT offer.id, offer.created_at, offer.updated_at, offer.title, offer.about, offer.requirements, offer.benefits, offer.status, offer.min_wage, offer.max_wage, offer.company_id, company.name as company_name, company.image_url as company_image_url
FROM offer
JOIN company ON offer.company_id = company.id
WHERE company.id = ? 
ORDER BY offer.created_at DESC
LIMIT ? OFFSET ?
`

type GetOffersByCompanyParams struct {
	ID     string
	Limit  int32
	Offset int32
}

type GetOffersByCompanyRow struct {
	ID              string
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Title           string
	About           string
	Requirements    string
	Benefits        string
	Status          int32
	MinWage         int32
	MaxWage         int32
	CompanyID       string
	CompanyName     string
	CompanyImageUrl string
}

func (q *Queries) GetOffersByCompany(ctx context.Context, arg GetOffersByCompanyParams) ([]GetOffersByCompanyRow, error) {
	rows, err := q.db.QueryContext(ctx, getOffersByCompany, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOffersByCompanyRow
	for rows.Next() {
		var i GetOffersByCompanyRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.About,
			&i.Requirements,
			&i.Benefits,
			&i.Status,
			&i.MinWage,
			&i.MaxWage,
			&i.CompanyID,
			&i.CompanyName,
			&i.CompanyImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOffersByQuery = `-- name: GetOffersByQuery :many
SELECT offer.id, offer.created_at, offer.updated_at, offer.title, offer.about, offer.requirements, offer.benefits, offer.status, offer.min_wage, offer.max_wage, offer.company_id, company.name as company_name, company.image_url as company_image_url
FROM offer
JOIN company ON offer.company_id = company.id
WHERE offer.title LIKE CONCAT('%', ?, '%') AND offer.status = 1
ORDER BY offer.created_at DESC
LIMIT ? OFFSET ?
`

type GetOffersByQueryParams struct {
	CONCAT interface{}
	Limit  int32
	Offset int32
}

type GetOffersByQueryRow struct {
	ID              string
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Title           string
	About           string
	Requirements    string
	Benefits        string
	Status          int32
	MinWage         int32
	MaxWage         int32
	CompanyID       string
	CompanyName     string
	CompanyImageUrl string
}

func (q *Queries) GetOffersByQuery(ctx context.Context, arg GetOffersByQueryParams) ([]GetOffersByQueryRow, error) {
	rows, err := q.db.QueryContext(ctx, getOffersByQuery, arg.CONCAT, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOffersByQueryRow
	for rows.Next() {
		var i GetOffersByQueryRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.About,
			&i.Requirements,
			&i.Benefits,
			&i.Status,
			&i.MinWage,
			&i.MaxWage,
			&i.CompanyID,
			&i.CompanyName,
			&i.CompanyImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOffersByUser = `-- name: GetOffersByUser :many
SELECT offer.id, offer.created_at, offer.updated_at, offer.title, offer.about, offer.requirements, offer.benefits, offer.status, offer.min_wage, offer.max_wage, offer.company_id, company.name as company_name, company.image_url as company_image_url
FROM offer
JOIN company ON offer.company_id = company.id
JOIN user ON company.user_id = user.id
WHERE user.id = ? 
ORDER BY offer.created_at DESC
LIMIT ? OFFSET ?
`

type GetOffersByUserParams struct {
	ID     string
	Limit  int32
	Offset int32
}

type GetOffersByUserRow struct {
	ID              string
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Title           string
	About           string
	Requirements    string
	Benefits        string
	Status          int32
	MinWage         int32
	MaxWage         int32
	CompanyID       string
	CompanyName     string
	CompanyImageUrl string
}

func (q *Queries) GetOffersByUser(ctx context.Context, arg GetOffersByUserParams) ([]GetOffersByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getOffersByUser, arg.ID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOffersByUserRow
	for rows.Next() {
		var i GetOffersByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.About,
			&i.Requirements,
			&i.Benefits,
			&i.Status,
			&i.MinWage,
			&i.MaxWage,
			&i.CompanyID,
			&i.CompanyName,
			&i.CompanyImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParticipatedOffers = `-- name: GetParticipatedOffers :many
SELECT offer.id, offer.created_at, offer.updated_at, offer.title, offer.about, offer.requirements, offer.benefits, offer.status, offer.min_wage, offer.max_wage, offer.company_id, company.name as company_name, company.image_url as company_image_url
FROM offer
JOIN company ON offer.company_id = company.id
JOIN quiz ON offer.id = quiz.offer_id
JOIN participation ON quiz.id = participation.quiz_id
WHERE participation.user_id = ?
ORDER BY participation.expires_at DESC
LIMIT ? OFFSET ?
`

type GetParticipatedOffersParams struct {
	UserID string
	Limit  int32
	Offset int32
}

type GetParticipatedOffersRow struct {
	ID              string
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Title           string
	About           string
	Requirements    string
	Benefits        string
	Status          int32
	MinWage         int32
	MaxWage         int32
	CompanyID       string
	CompanyName     string
	CompanyImageUrl string
}

func (q *Queries) GetParticipatedOffers(ctx context.Context, arg GetParticipatedOffersParams) ([]GetParticipatedOffersRow, error) {
	rows, err := q.db.QueryContext(ctx, getParticipatedOffers, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetParticipatedOffersRow
	for rows.Next() {
		var i GetParticipatedOffersRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.About,
			&i.Requirements,
			&i.Benefits,
			&i.Status,
			&i.MinWage,
			&i.MaxWage,
			&i.CompanyID,
			&i.CompanyName,
			&i.CompanyImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertOffer = `-- name: InsertOffer :exec
INSERT INTO offer
(id, title, about, requirements, benefits, min_wage, max_wage, company_id)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertOfferParams struct {
	ID           string
	Title        string
	About        string
	Requirements string
	Benefits     string
	MinWage      int32
	MaxWage      int32
	CompanyID    string
}

func (q *Queries) InsertOffer(ctx context.Context, arg InsertOfferParams) error {
	_, err := q.db.ExecContext(ctx, insertOffer,
		arg.ID,
		arg.Title,
		arg.About,
		arg.Requirements,
		arg.Benefits,
		arg.MinWage,
		arg.MaxWage,
		arg.CompanyID,
	)
	return err
}
