// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: offers.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const getOffer = `-- name: GetOffer :one
SELECT offer.id, offer.created_at, offer.updated_at, offer.title, offer.about, offer.requirements, offer.benefits, offer.status, offer.min_wage, offer.max_wage, offer.company_id, company.name as company_name
FROM offer
JOIN company ON offer.company_id = company.id
WHERE offer.id = ?
LIMIT 1
`

type GetOfferRow struct {
	ID           string
	CreatedAt    time.Time
	UpdatedAt    time.Time
	Title        string
	About        string
	Requirements string
	Benefits     string
	Status       int32
	MinWage      int32
	MaxWage      int32
	CompanyID    string
	CompanyName  string
}

func (q *Queries) GetOffer(ctx context.Context, id string) (GetOfferRow, error) {
	row := q.db.QueryRowContext(ctx, getOffer, id)
	var i GetOfferRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.About,
		&i.Requirements,
		&i.Benefits,
		&i.Status,
		&i.MinWage,
		&i.MaxWage,
		&i.CompanyID,
		&i.CompanyName,
	)
	return i, err
}

const getOfferByQuiz = `-- name: GetOfferByQuiz :one
SELECT offer.id, offer.created_at, offer.updated_at, offer.title, offer.about, offer.requirements, offer.benefits, offer.status, offer.min_wage, offer.max_wage, offer.company_id
FROM offer
JOIN quiz ON offer.id = quiz.offer_id
WHERE quiz.id = ?
LIMIT 1
`

func (q *Queries) GetOfferByQuiz(ctx context.Context, id string) (Offer, error) {
	row := q.db.QueryRowContext(ctx, getOfferByQuiz, id)
	var i Offer
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.About,
		&i.Requirements,
		&i.Benefits,
		&i.Status,
		&i.MinWage,
		&i.MaxWage,
		&i.CompanyID,
	)
	return i, err
}

const getOfferByUser = `-- name: GetOfferByUser :one
SELECT offer.id, offer.created_at, offer.updated_at, offer.title, offer.about, offer.requirements, offer.benefits, offer.status, offer.min_wage, offer.max_wage, offer.company_id, company.name as company_name
FROM offer
JOIN company ON offer.company_id = company.id
JOIN user ON company.user_id = user.id
WHERE offer.id = ? AND user.id = ?
LIMIT 1
`

type GetOfferByUserParams struct {
	ID   string
	ID_2 string
}

type GetOfferByUserRow struct {
	ID           string
	CreatedAt    time.Time
	UpdatedAt    time.Time
	Title        string
	About        string
	Requirements string
	Benefits     string
	Status       int32
	MinWage      int32
	MaxWage      int32
	CompanyID    string
	CompanyName  string
}

func (q *Queries) GetOfferByUser(ctx context.Context, arg GetOfferByUserParams) (GetOfferByUserRow, error) {
	row := q.db.QueryRowContext(ctx, getOfferByUser, arg.ID, arg.ID_2)
	var i GetOfferByUserRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Title,
		&i.About,
		&i.Requirements,
		&i.Benefits,
		&i.Status,
		&i.MinWage,
		&i.MaxWage,
		&i.CompanyID,
		&i.CompanyName,
	)
	return i, err
}

const getOffers = `-- name: GetOffers :many
SELECT offer.id, offer.created_at, offer.updated_at, offer.title, offer.about, offer.requirements, offer.benefits, offer.status, offer.min_wage, offer.max_wage, offer.company_id, company.name as company_name, company.image_url as company_image_url
FROM offer
JOIN company ON offer.company_id= company.id
WHERE offer.status = 1
ORDER BY offer.created_at DESC
LIMIT 10
`

type GetOffersRow struct {
	ID              string
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Title           string
	About           string
	Requirements    string
	Benefits        string
	Status          int32
	MinWage         int32
	MaxWage         int32
	CompanyID       string
	CompanyName     string
	CompanyImageUrl sql.NullString
}

func (q *Queries) GetOffers(ctx context.Context) ([]GetOffersRow, error) {
	rows, err := q.db.QueryContext(ctx, getOffers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOffersRow
	for rows.Next() {
		var i GetOffersRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.About,
			&i.Requirements,
			&i.Benefits,
			&i.Status,
			&i.MinWage,
			&i.MaxWage,
			&i.CompanyID,
			&i.CompanyName,
			&i.CompanyImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOffersByQuery = `-- name: GetOffersByQuery :many
SELECT offer.id, offer.created_at, offer.updated_at, offer.title, offer.about, offer.requirements, offer.benefits, offer.status, offer.min_wage, offer.max_wage, offer.company_id, company.name as company_name, company.image_url as company_image_url
FROM offer
JOIN company ON offer.company_id = company.id
WHERE offer.title LIKE CONCAT('%', ?, '%')
ORDER BY offer.created_at DESC
LIMIT 10
`

type GetOffersByQueryRow struct {
	ID              string
	CreatedAt       time.Time
	UpdatedAt       time.Time
	Title           string
	About           string
	Requirements    string
	Benefits        string
	Status          int32
	MinWage         int32
	MaxWage         int32
	CompanyID       string
	CompanyName     string
	CompanyImageUrl sql.NullString
}

func (q *Queries) GetOffersByQuery(ctx context.Context, concat interface{}) ([]GetOffersByQueryRow, error) {
	rows, err := q.db.QueryContext(ctx, getOffersByQuery, concat)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOffersByQueryRow
	for rows.Next() {
		var i GetOffersByQueryRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.About,
			&i.Requirements,
			&i.Benefits,
			&i.Status,
			&i.MinWage,
			&i.MaxWage,
			&i.CompanyID,
			&i.CompanyName,
			&i.CompanyImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOffersByUser = `-- name: GetOffersByUser :many
SELECT offer.id, offer.created_at, offer.updated_at, offer.title, offer.about, offer.requirements, offer.benefits, offer.status, offer.min_wage, offer.max_wage, offer.company_id, company.name as company_name
FROM offer
JOIN company ON offer.company_id = company.id
JOIN user ON company.user_id = user.id
WHERE user.id = ? 
ORDER BY offer.created_at DESC
LIMIT 10
`

type GetOffersByUserRow struct {
	ID           string
	CreatedAt    time.Time
	UpdatedAt    time.Time
	Title        string
	About        string
	Requirements string
	Benefits     string
	Status       int32
	MinWage      int32
	MaxWage      int32
	CompanyID    string
	CompanyName  string
}

func (q *Queries) GetOffersByUser(ctx context.Context, id string) ([]GetOffersByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getOffersByUser, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOffersByUserRow
	for rows.Next() {
		var i GetOffersByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.About,
			&i.Requirements,
			&i.Benefits,
			&i.Status,
			&i.MinWage,
			&i.MaxWage,
			&i.CompanyID,
			&i.CompanyName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertOffer = `-- name: InsertOffer :exec
INSERT INTO offer
(id, title, about, requirements, benefits, min_wage, max_wage, company_id)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertOfferParams struct {
	ID           string
	Title        string
	About        string
	Requirements string
	Benefits     string
	MinWage      int32
	MaxWage      int32
	CompanyID    string
}

func (q *Queries) InsertOffer(ctx context.Context, arg InsertOfferParams) error {
	_, err := q.db.ExecContext(ctx, insertOffer,
		arg.ID,
		arg.Title,
		arg.About,
		arg.Requirements,
		arg.Benefits,
		arg.MinWage,
		arg.MaxWage,
		arg.CompanyID,
	)
	return err
}
